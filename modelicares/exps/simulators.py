#!/usr/bin/python
# -*- coding: utf-8 -*-
"""Context managers to be used as simulators

In general, the context managers are used like this:

.. code-block:: python

   >>> with context_manager() as simulator: # doctest: +SKIP
   ...     simulator.run(model1, params1)
   ...     simulator.run(model2, params2)
   ...     # ...

For more details, see the documentation for the context managers below:

- :class:`dymola_script` - Write a Dymola\ :sup:`®`-formatted script

- :class:`dymosim` - Run executable models from Dymola\ :sup:`®`

- :class:`fmi` - Simulate FMUs_ via PyFMI_

The :class:`dymosim` and :class:`fmi` are interactive simulators whose
:meth:run` methods return :class:`DymosimSimulation` or :class:`FMISimulation`
instances (see below).

.. inheritance-diagram:: Simulation DymolaSimulation FMISimulation


.. _FMUs: https://www.fmi-standard.org/
.. _PyFMI: http://www.pyfmi.org/
"""
__author__ = "Kevin Davies and Arnout Aertgeerts"
__email__ = "kdavies4@gmail.com"
__copyright__ = ("Copyright 2012-2014, Kevin Davies, Hawaii Natural Energy "
                 "Institute, and Georgia Tech Research Corporation")
__license__ = "BSD-compatible (see LICENSE.txt)"

import os
import sys

from datetime import date
from multiprocessing import Pool
from shutil import copy, move, rmtree
from . import read_options, read_params, write_options, write_params
from ..simres import SimRes, SimResSequence
from ..util import ParamDict, call, cleanpath

# OS-dependent strings
EXE = '.exe' if os.name == 'nt' else '' # File extension for an executable
EXEC_PREFIX = '' if os.name == 'nt' else './' # Prefix to execute a file


class dymola_script(object):

    """Context manager to write a Dymola\ :sup:`®`-formatted script

    **Initialization parameters (defaults in parentheses):**

    - *fname* ("run_sims.mos"): Name of the script file to be written, relative
      to the current directory

    - *command* ('simulateModel'): Simulation or other command to
      Dymola\ :sup:`®`

         Besides 'simulateModel', this can be 'linearizeModel' to create a state
         space representation or 'translateModel' to create executables without
         running them.

    - *working_dir* (''): Working directory where the executable, log files,
      etc. are initially created (relative to the current directory)

         '~' may be included to represent the user directory.

    - *results* (['dsin.txt', 'dslog.txt', 'dsres.mat', 'dymolalg.txt',
      'dymosim%x']): List of files to copy to the results folder, besides
      dsfinal.txt

         Each entry is the name or path of a file that is generated by the
         command.  The path is relative to *working_dir*.  '%x' may be included
         in the name to represent '.exe' if the operating system is Windows and
         '' otherwise.  The result folders are named by the simulation number
         and placed within the folder contains the script (*fname*).

    - *packages* ([]): List of Modelica_ packages that should be preloaded or
      scripts that should be run before the experiments

         Each may be a "\*.mo" file, a folder that contains a "package.mo" file,
         or a "\*.mos" file.  The path may be absolute or relative to
         *working_dir*.  The Modelica Standard Library does not need to be
         included since it is loaded automatically.  If an entry is a script
         ("\*.mos"), it is run from its folder.

    - *\*\*options*: Additional keyword arguments for *command*

         Any option with a value of `None` will be skipped.

         These arguments can also be added, modified, or removed after
         initialization.  Please see Example 2 below.

         If *command* is 'simulateModel', then the following keywords may be
         used.  The defaults (in parentheses) are applied by Dymola\ :sup:`®`,
         not by this context manager.

         - *startTime* (0): Start of simulation

         - *stopTime* (1): End of simulation

         - *numberOfIntervals* (0): Number of output points

         - *outputInterval* (0): Distance between output points

         - *method* ("Dassl"): Integration method

         - *tolerance* (0.0001): Tolerance of integration

         - *fixedstepsize* (0): Fixed step size for Euler

         - *resultFile* ("dsres.mat"): Where to store result

    **Example 1 (a single simulation):**

    .. code-block:: python

       >>> from modelicares.exps.simulators import dymola_script

       >>> with dymola_script("examples/ChuaCircuit/run_sims1.mos", stopTime=2500) as simulator: # doctest: +ELLIPSIS
       ...     simulator.run('Modelica.Electrical.Analog.Examples.ChuaCircuit')
       Starting to write the Dymola script...
       Run 1:  simulateModel(...)
       Finished writing the Dymola script.

    This generates a summary of the runs in *examples/ChuaCircuit/runs.tsv*:

    ===== ============= ============= ===============================================
    Run # Command       Options       Model & parameters
    ===== ============= ============= ===============================================
    1     simulateModel stopTime=2500 Modelica.Electrical.Analog.Examples.ChuaCircuit
    ===== ============= ============= ===============================================

    and the following script in *examples/ChuaCircuit/run_sims1.mos*:

    .. code-block:: modelica

       // Dymola script written by ModelicaRes...
       import Modelica.Utilities.Files.copy;
       import Modelica.Utilities.Files.createDirectory;
       Advanced.TranslationInCommandLog = true "Also include translation log in command log";
       cd("...");
       destination = ".../examples/ChuaCircuit/";

       // Run 1
       ok = simulateModel(problem="Modelica.Electrical.Analog.Examples.ChuaCircuit", stopTime=2500);
       if ok then
           savelog();
           dest = destination + "1/";
           createDirectory(dest);
           copy("dsin.txt", dest + "dsin.txt", true);
           copy("dslog.txt", dest + "dslog.txt", true);
           copy("dsres.mat", dest + "dsres.mat", true);
           copy("dymosim", dest + "dymosim...", true);
           copy("dymolalg.txt", dest + "dymolalg.txt", true);
       end if;
       clearlog();

       exit();

    where ``...`` depends on the local system.

    **Example 2 (simulating with different options):**

    The default options can also be modified or removed after establishing the
    context:

    .. code-block:: python

       >>> from modelicares.exps.simulators import dymola_script

       >>> with dymola_script("examples/ChuaCircuit/run_sims2.mos", stopTime=250) as simulator: # doctest: +ELLIPSIS
       ...     simulator.run('Modelica.Electrical.Analog.Examples.ChuaCircuit', stopTime=2500)
       ...     simulator.run('Modelica.Electrical.Analog.Examples.ChuaCircuit')
       ...     del simulator.stopTime
       ...     simulator.run('Modelica.Electrical.Analog.Examples.ChuaCircuit')
       ...     simulator.stopTime = 25
       ...     simulator.run('Modelica.Electrical.Analog.Examples.ChuaCircuit')
       Starting to write the Dymola script...
       Run 1:  simulateModel(...)
       Run 2:  simulateModel(...)
       ...
       Finished writing the Dymola script.

    Initially the stop time is set at 250 s, but in the first run it is
    temporarily overwritten to 2500 s.  In the second run, it falls back to its
    initial setting.  The stop time is removed before the third run and then set
    to 25 s for the final run.

    This generates the following table:

    ===== ============= ============= ===============================================
    Run # Command       Options       Model & parameters
    ===== ============= ============= ===============================================
    1     simulateModel stopTime=2500 Modelica.Electrical.Analog.Examples.ChuaCircuit
    2     simulateModel stopTime=250  Modelica.Electrical.Analog.Examples.ChuaCircuit
    3     simulateModel               Modelica.Electrical.Analog.Examples.ChuaCircuit
    4     simulateModel stopTime=25   Modelica.Electrical.Analog.Examples.ChuaCircuit
    ===== ============= ============= ===============================================

    and a corresponding script in *examples/ChuaCircuit/run_sims2.mos*.

    **Example 3 (full-factorial design of experiments):**

    Multiple parameters can be adjusted using functions from the
    :mod:`~modelicares.exps.doe` module.

    .. code-block:: python

       >>> from modelicares.exps.simulators import dymola_script
       >>> from modelicares import doe

       >>> with dymola_script("examples/ChuaCircuit/run_sims3.mos") as simulator: # doctest: +ELLIPSIS
       ...     for params in doe.fullfact({'C1.C': [8, 10], 'L.L': [18, 20]}):
       ...         simulator.run("Modelica.Electrical.Analog.Examples.ChuaCircuit", params=params)
       Starting to write the Dymola script...
       Run 1:  simulateModel(...)
       ...
       Run 4:  simulateModel(...)
       Finished writing the Dymola script.

    This generates the following table:

    ===== ============= ======= ==================================================================
    Run # Command       Options Model & parameters
    ===== ============= ======= ==================================================================
    1     simulateModel         Modelica.Electrical.Analog.Examples.ChuaCircuit(C1(C=8), L(L=18))
    2     simulateModel         Modelica.Electrical.Analog.Examples.ChuaCircuit(C1(C=10), L(L=18))
    3     simulateModel         Modelica.Electrical.Analog.Examples.ChuaCircuit(C1(C=8), L(L=20))
    4     simulateModel         Modelica.Electrical.Analog.Examples.ChuaCircuit(C1(C=10), L(L=20))
    ===== ============= ======= ==================================================================

    and a corresponding script in *examples/ChuaCircuit/run_sims3.mos*.


    .. _Modelica: http://www.modelica.org/
    """

    def __init__(self, fname="run_sims.mos", command='simulateModel',
                 working_dir='',
                 results=['dsin.txt', 'dslog.txt', 'dsres.mat', 'dymolalg.txt',
                          'dymosim%x'],
                 packages=[], **options):
        """Upon initialization, start writing the script.

        See the top-level class documentation.
        """

        # Pre-process and store the arguments.
        fname = cleanpath(fname)
        self._command = command
        working_dir = cleanpath(working_dir)
        output_dir = os.path.dirname(fname)
        for i, result in enumerate(results):
            results[i] = result.replace('%x', EXE)
        self._results = results
        self._options = options

        # Open the script.
        print("Starting to write the Dymola script...")
        mos = open(fname, 'w')
        self._mos = mos

        # Write the header.
        mos.write('// Dymola script written by ModelicaRes %s\n'
                  % date.isoformat(date.today()))
        mos.write('import Modelica.Utilities.Files.copy;\n')
        mos.write('import Modelica.Utilities.Files.createDirectory;\n')
        mos.write('Advanced.TranslationInCommandLog = true "Also include '
                  'translation log in command log";\n')
        mos.write('cd("%s");\n' % working_dir)
        for package in packages:
            if package.endswith('.mos'):
                mos.write('cd("%s");\n' % os.path.dirname(package))
                mos.write('RunScript("%s");\n' % os.path.basename(package))
            else:
                if package.endswith('.mo'):
                    mos.write('openModel("%s");\n' % package)
                else:
                    mos.write('openModel("%s");\n' % os.path.join(package,
                                                                  'package.mo'))
            mos.write('cd("%s");\n' % working_dir)
        mos.write('destination = "%s";\n\n'
                  % (os.path.normpath(output_dir) + os.path.sep))
        # Sometimes Dymola opens with an error; simulate any model to clear the
        # error.
        # mos.write('simulateModel("Modelica.Electrical.Analog.Examples.'
        #           'ChuaCircuit");\n\n')

        # Start the run log.
        log = open(os.path.join(output_dir, "runs.tsv"), 'w')
        log.write("Run #\tCommand\tOptions\tModel & parameters\n")
        self._log = log

        # Start counting the run() calls.
        self.simulation = 0

    def __delattr__(self, attr):
        """Delete a default option.
        """
        del self._options[attr]

    def __getattr__(self, attr):
        """If an unknown attribute is requested, look for it in the dictionary
        of default options.
        """
        return self._options[attr]

    def __setattr__(self, attr, value):
        """Add known attributes directly, but unknown attributes go to the
        dictionary of default options.
        """
        if attr in ('_command', '_log', '_mos', '_options', '_results',
                    'interval', 'simulation'):
            object.__setattr__(self, attr, value) # Traditional method
        else:
            self._options[attr] = value

    def __enter__(self):
        """Enter the context of the simulator.
        """
        # Everything has been done in __init__, so just do this:
        return self

    def __exit__(self, *exc_details):
        """Exit the context of the simulator.
        """
        # Write the command to exit the simulation environment.
        # Otherwise, the script will hang until it's closed manually.
        self._mos.write("exit();\n")
        self._mos.close()

        self._log.close()
        print("Finished writing the Dymola script.")

    def run(self, model=None, params={}, **options):
        """Write commands to run and save the results of a single experiment.

        **Parameters:**

        - *model*: String representing the name of the model, including the
          full Modelica_ path (in dot notation)

             If *model* is `None`, then the model is not included in the
             command.  Dymola\ :sup:`®` will use the last translated model.

        - *params*: Dictionary of parameter names and values to be set within
          the model

             The keys or variable names in this dictionary must indicate the
             hierarchy within the model---either in Modelica_ dot ('.') notation
             or via nested dictionaries.  If *model* is `None`, then *params* is
             ignored.  Python_ values are automatically represented in Modelica_
             syntax (see :meth:`~modelicares.exps.ParamDict.__str__`).
             Redeclarations and other prefixes must be included in the keys
             along with the class names (e.g.,
             ``params={'redeclare package Medium': 'Modelica.Media.Air.MoistAir'}``).

             Any item with a value of `None` is skipped.

        - *\*\*options*: Additional or modified keyword arguments for the
          command chosen upon initialization (see the top-level documentation of
          this context manager, :class:`dymola_script`)

             Any option with a value of `None` will be skipped.

             These are applied only for the current simulation.  They override
             the options given at initialization or set via attribute access.

        Please see the examples in the top-level documentation of
        :class:`dymola_script`.
        """
        # Increment the number of runs and reset the number of intervals.
        self.simulation += 1
        self.interval = 1

        # Retrieve some attributes.
        simulation = self.simulation
        mos = self._mos
        command = self._command
        opts = self._options.copy()
        opts.update(options)

        # Write the command to run the model.
        mos.write('// Run %i\n' % simulation)
        problem = '"%s%s"' % (model, ParamDict(params)) if model else None
        call = '%s%s' % (command, ParamDict(opts, problem=problem))
        mos.write('ok = %s;\n' % call)

        # Write commands to save the results and clear Dymola's log file.
        mos.write('if ok then\n')
        mos.write('    savelog();\n')
        mos.write('    dest = destination + "%s%s";\n' % (simulation,
                                                          os.path.sep))
        mos.write('    createDirectory(dest);\n')
        for result in self._results:
            new_name = str(self.interval).join(os.path.splitext(result))
            mos.write('    copy("%s", dest + "%s", true);\n'
                      % (result, new_name))
        mos.write('    copy("dsfinal.txt", dest + "dsfinal.txt", true);\n'
                  % (result, new_name))
        mos.write('end if;\n')
        mos.write('clearlog();\n\n')

        # Add an entry to the run log.
        self._log.write('\t'.join([str(simulation),
                                   command,
                                   str(ParamDict(opts))[1:-1],
                                   problem[1:-1] if problem else ''])
                        + '\n')
        print('Run %s:  %s' % (simulation, call))

    # TODO: Consider adding a cont() method like in dymosim below.  The main
    # difficulty is that it's impossible to access stopTime programmatically in
    # Dymola (due to problems with assignment from Dymola's getExperiment()
    # function). Therefore, it's not possible to set the new stopTime based on
    # duration.

class Simulation(object):
    """Class to represent an ongoing simulation

    This class is returned by :meth:`dymosim.run` or :meth:`fmi.run`.  It is not
    intended for direct instantiation.

    **Methods:**

    - :meth:`wait` - Wait until the last interval has been simulated or until a
      timeout passes.

    **Properties:**

    - :attr:`simulation_num` - Number of this simulation

    - :attr:`interval_num` - Number of intervals which have been started so far

    - :attr:`model` - File name of the model

    - :attr:`ready` - `True`, if the last simulation interval has completed

    - :attr:`result` - The simulation result as an instance of
      :class:`modelicares.simres.SimRes` or
      :class:`modelicares.simres.SimResSquence`.
    """
    def __init__(self, model, params, options, simulation_num, log, pool,
                 output_dir, **kwargs):
        """Initialize the simulation and run the first interval.
        """
        self._model = model
        self._params = {}
        self._options = {}
        self._simulation_num = simulation_num
        self._interval_num = 0
        self._log = log
        self._pool = pool
        self._output_dir = os.path.join(output_dir, str(simulation_num))
        self._kwargs = kwargs
        self._run(params, **options)

    def _run(self, params={}, **options):
        """Continue the simulation from the end of the last interval (after
        waiting for it to finish).
        """
        self._params.update(params)
        self._options.update(options)
        self._interval_num += 1

        # Write a log entry.
        items = [str(self._simulation_num), str(self._interval_num),
                 str(ParamDict(self._options))[1:-1], self._model,
                 str(ParamDict(self._params))[1:-1]]
        self._log.write('\t'.join(items) + '\n')

        # Set the parameters and options, run the model, and save the results.
        kwargs = dict(model=self._model, params=self._params,
                      options=self._options,
                      simulation_num=self._simulation_num,
                      interval_num=self._interval_num, silent=bool(self._pool),
                      output_dir=self._output_dir, **self._kwargs)

        if self._pool:
            # Asynchronous (parallel)
            #print("async")
            self._process = self._pool.apply_async(_RUN_DYMOSIM, [], kwargs)
        else:
            # Synchronous (serial)
            #print("sync")
            _RUN_DYMOSIM(**kwargs)

    @property
    def simulation_num(self):
        """Number of this simulation
        """
        return self._simulation_num

    @property
    def interval_num(self):
        """Number of intervals which have been started so far
        """
        return self._interval_num

    @property
    def model(self):
        """File name of the model
        """
        return self._model + EXE

    @property
    def ready(self):
        """`True`, if the last simulation interval has completed
        """
        if self._pool:
            return self._process.ready()
        return True

    @property
    def result(self):
        """The simulation result

        This will block until the last interval is finished.

        If there is only one simulation interval, the result is a
        :class:`modelicares.simres.SimRes` instance.  Otherwise, the result is a
        :class:`modelicares.simres.SimResSquence` containing the data from all
        of the intervals.
        """
        if self._pool:
            self.wait()
        if self.interval_num == 1:
            return SimRes(os.path.join(self._output_dir, 'dsres1.mat'))
        else:
            return SimResSequence(*[os.path.join(self._output_dir, 'dsres%i.mat'
                                    % (i + 1)) for i in range(self._interval_num)])

    def wait(self, timeout=None):
        """Wait until the last interval has been simulated or until *timeout*
        seconds pass.
        """
        if self._pool:
            self._process.wait(timeout)

class DymosimSimulation(Simulation):
    """Class to represent a dymosim-based simulation

    This class is returned by :meth:`dymosim.run`.  It is not intended for
    direct instantiation.

    **Methods:**

    - :meth:`cont`: Continue the simulation from the end of the last interval.

    See :class:`Simulation` for the inherited methods and properties.
    """
    def cont(self, duration, params={}, **options):
        """Continue the simulation from the end of the last interval (after
        waiting for it to finish).

        **Parameters:**

        - *duration*: Number of additional seconds to simulate

        - *params*: Dictionary of names and values of parameters to be adjusted
          within the model

             By default, the parameters remain as they were in the last
             :meth:`run`.  See that method for details on *params*.

        - *\*\*options*: Adjustments to the simulation settings under
          "Experiment parameters", "Method tuning parameters", and "Output
          parameters" in the initialization file

             Any option with a value of `None` will be ignored.

             For common parameters, see the initialization parameters in the
             top-level documentation of this context manager,  :class:`dymosim`.

             These are applied only for the current simulation.  They
             temporarily override the options given at initialization (see the
             top-level documentation of :class:`dymosim`) or set via attribute
             access.

        .. warning::

           Be careful not to use *params* to adjust variables with tunable
           initial values.  Otherwise, the new simulation will not continue
           where the last one left off.
        """
        # Wait for the previous simulation interval to finish.
        self.wait()

        # Establish the start and stop times.
        start_time = read_options('StopTime',
                                  os.path.join(self._output_dir, 'dsfinal.txt'))
        options['StartTime'] = start_time
        options['StopTime'] = start_time + duration

        # Continue the simulation.
        self._run(params, **options)
        return self

class FMISimulation(Simulation):
    """Class to represent an FMI-based simulation

    This class is returned by :meth:`fmi.run`.  It is not intended for direct
    instantiation.

    **Methods:**

    - :meth:`cont`: Continue the simulation from the end of the last interval.

    See :class:`Simulation` for the inherited methods and properties.
    """
    def __init__(self):
        raise NotImplementedError # TODO

class _InteractiveSimulator(object):
    """Base class for a simulator whose results can be accessed between runs.

    **Initialization parameters (defaults in parentheses):**

    - *output_dir* (''): Directory in which to store the results, relative to
      the current directory

    - *async* (`True`): If `True`, run simulations asynchronously (in parallel).
    """

    def __init__(self, output_dir='', async=True, **options):
        """Initialize the simulator.

        See the top-level class documentation.
        """
        # Prepare for asynchronous simulation.
        self._pool = Pool() if async else None

        # Create the results directory.
        self._output_dir = cleanpath(output_dir)
        if not os.path.isdir(self._output_dir):
            os.makedirs(self._output_dir)

        # No simulations yet
        self._simulation_num = 0

        # Save the options.
        self._options = options

    def __enter__(self):
        """Enter the context of the simulator.
        """
        self._log = open(os.path.join(self._output_dir, "runs.tsv"), 'w')
        self._log.write("Simulation #\tInterval #\tOptions\tModel"
                        "\tParameters & initial values\n")

        return self

    def __exit__(self, *exc_details):
        """Exit the context of the simulator.
        """
        self._log.close()
        if self._pool:
            self._pool.close()
            self._pool.join() # Wait for all processes to exit.

    def __delattr__(self, attr):
        """Delete a simulation option.
        """
        del self._options[attr]

    def __getattr__(self, attr):
        """If an unknown attribute is requested, assume it is a simulation
        option.
        """
        return self._options[attr]

    def __setattr__(self, attr, value):
        """If an attribute is known, then add it directly; otherwise, assume it
        is a simulation option.
        """
        if attr in ('_log', '_options', '_output_dir', '_pool',
                    '_simulation_num'):
            object.__setattr__(self, attr, value) # Traditional method
        else:
            self._options[attr] = value

    def run(self):
        """Run and save the results of a single experiment.
        """
        self._simulation_num += 1

        # Create the results folder.
        output_dir = os.path.join(self._output_dir, str(self._simulation_num))
        if not os.path.isdir(output_dir):
            os.makedirs(output_dir)

    @property
    def simulation_num(self):
        """Number of simulations started so far
        """
        return self._simulation_num

def _RUN_DYMOSIM(model, params, options, simulation_num, interval_num, silent,
                 command, output_dir):
    "Run or continue a dymosim simulation."

    # Rename the last dsin file.
    dsin_name = 'dsin%i.txt' % interval_num
    dsin_path = os.path.join(output_dir, dsin_name)
    move(os.path.join(output_dir, 'dsfinal.txt'), dsin_path)

    # Write the model parameters, initial conditions, and options to the
    # dsin file.
    if params:
        write_params(params, dsin_path)
    if options:
        write_options(options, dsin_path)

    # Run the model.
    args = [EXEC_PREFIX + model + EXE, command,
            '-f', os.path.join(output_dir, 'dsfinal.txt'), # Final params
            '-w', os.path.join(output_dir, 'dslog%i.txt' % interval_num), # Log
            dsin_path, # Initial params
            os.path.join(output_dir, 'dsres%i.mat' % interval_num)] # Trajectory
    call(args, silent)

class dymosim(_InteractiveSimulator):

    """Context manager to run executable models from Dymola\ :sup:`®`

    **Initialization parameters (defaults in parentheses):**

    - *command* ('-s'): Simulation or other action command to dymosim.

         Besides '-s', this can be '-l' to create a state space representation.

    - *output_dir* (''): Directory in which to store the results, relative to
      the current directory

    - *debug* (*False*): If `True`, print the dymosim messages.

         In debugging mode, simulations run synchronously so that the display
         can be matched to individual simulations.

    - *\*\*options*: Adjustments to the simulation settings under "Experiment
      parameters", "Method tuning parameters", and "Output parameters" in the
      initialization file (e.g., dsin.txt)

         See the initialization file for more information.  The common
         parameters are those under "Experiment parameters".  Note that they are
         named differently than those for :class:`dymola_script`:

         - *StartTime* (compare to *startTime*): Time at which integration
           starts

         - *StopTime* (compare to *stopTime*): Time at which integration stops

         - *Increment* (compare to *outputInterval*): Communication step size,
           if > 0

         - *nInterval* (compare to *numberOfIntervals*): Number of communication
           intervals, if > 0

         - *Tolerance* (compare to *tolerance*): Relative precision of signals
           for simulation

         - *MaxFixedStep* (compare to *fixedstepsize*): Maximum step size of
           fixed step size integrators, if > 0.0

         - *Algorithm* (compare to *method*): Integration algorithm (accepts an
           integer instead of a string)

         Any option with a value of `None` will be skipped.

         These arguments can also be added, modified, or removed after
         initialization.  Please see Example 2 of :class:`dymola_script`; the
         same approach can be used with this context manager (:class:`dymosim`).

    The results are placed in *output_dir* in subfolders named by the
    simulation number.  Within each subfolder, the files in the *results* list
    as well as the trajectory (dsres.mat) and initial values (dsin.txt) are
    renamed with the interval number just before the file extension.  The
    :meth:`run` method runs the first interval (e.g., producing dsres1.mat and
    dsin1.txt) and returns a :class:`DymosimSimulation` instance.  Its
    :meth:`DymosimSimulation.cont` method continues with intervals 2, 3, etc.
    The final values (dsfinal.txt) are those of the last interval and are copied
    directly.

    **Example:**

    .. code-block:: python

       >>> from modelicares.exps.simulators import dymosim

       >>> with dymosim(StopTime=2500) as simulator: # doctest: +ELLIPSIS
       ...     simulator.run('examples/ChuaCircuit/dymosim')

    Notice that this is similar to Example 1 of :class:`dymola_script`.
    Likewise, the form of Examples 2 and 3 for that context manager holds for
    this one.
    """

    def __init__(self, command='-s', output_dir='', debug=False, **options):
        """Initialize the simulator.

        See the top-level class documentation.
        """
        self._command = command
        _InteractiveSimulator.__init__(self, output_dir, async=not debug,
                                       **options)

    def __setattr__(self, attr, value):
        """If an attribute is known, then add it directly; otherwise, assume it
        is a simulation option.
        """
        if attr == '_command':
            object.__setattr__(self, attr, value) # Traditional method
        else:
            _InteractiveSimulator.__setattr__(self, attr, value)

    def run(self, model='dymosim', params={}, **options):
        r"""Run and save the results of a single experiment.

        **Parameters:**

        - *model*: String representing the directory and base name of the model
          executable

             '.exe' should not be included. It will be added automatically if
             the operating system is Windows.

             If the base name of the model is 'dymosim', then an initialization
             file named 'dsin.txt' is expected in the same directory as the
             model.  Otherwise, the initialization file should be named
             <base name> + '_dsin.txt'.  If an initialization file does not
             exist with this naming convention, then it will be created.

        - *params*: Dictionary of names and values of parameters and variables
          with tunable initial values to be set within the model

             The keys or variable names in this dictionary must indicate the
             hierarchy within the model---either in Modelica_ dot ('.') notation
             or via nested dictionaries.  Due to the format of the
             initialization files, arrays must be broken into scalars by
             indicating the indices (Modelica_ 1-based indexing) in the key
             along with the variable name.  Also, enumerations and Booleans must
             be given as their unsigned integer equivalents (e.g., 0 for
             *False*).  Strings and prefixes are not supported.

             Any item with a value of `None` is ignored.

        - *\*\*options*: Adjustments to the simulation settings under
          "Experiment parameters", "Method tuning parameters", and "Output
          parameters" in the initialization file

             Any option with a value of `None` will be ignored.

             For common parameters, see the initialization parameters in the
             top-level documentation of this context manager,  :class:`dymosim`.

             These are applied only for the current simulation.  They
             temporarily override the options given at initialization (see the
             top-level documentation of :class:`dymosim`) or set via attribute
             access.

        **Returns:**

        A :class:`DymosimSimulation` instance

        Please see the example in the top-level documentation of
        :class:`dymosim`.
        """
        _InteractiveSimulator.run(self)

        # Find the original dsin file.
        model_dir, model = os.path.split(model)
        if model == 'dymosim':
            orig_dsin_name = 'dsin.txt'
        else:
            orig_dsin_name = model + '_dsin.txt'
        orig_dsin_path = os.path.join(model_dir, orig_dsin_name)
        # Create it if necessary.
        model += EXE
        if not os.path.isfile(orig_dsin_path):
            call([EXEC_PREFIX + model, '-i', orig_dsin_name], silent=True)

        # Copy the dsin file into the results folder.
        dsin_path = os.path.join(self._output_dir, str(self._simulation_num),
                                 'dsfinal.txt')
        copy(orig_dsin_path, dsin_path)

        # Start the simulation.
        cummulative_options = self._options.copy()
        cummulative_options.update(options)
        return DymosimSimulation(model, params, cummulative_options,
                                 simulation_num=self._simulation_num,
                                 log=self._log, pool=self._pool,
                                 output_dir=self._output_dir,
                                 command=self._command)

class fmi(object):

    """Context manager to simulate FMUs_ via PyFMI_

    .. Warning:: This context manager has not been implemented yet. TODO

    **Example:**

    .. code-block:: python

       >>> from modelicares.exps.simulators import fmi

       >>> with fmi(stopTime=2500) as simulator:
       ...     simulator.run('examples/ChuaCircuit.fmu')

    For more complicated scenarios, use the same form as in Examples 2 and 3
    in the :class:`dymola_script` documentation.
    """

    def __init__(self, output_dir='', **options):
        """Upon initialization, establish some settings.

        See the top-level class documentation.
        """

        # Pre-process and store the arguments.
        self._output_dir = cleanpath(output_dir)
        self._options = options

        # Dictionary for in memory results.  If the option
        # result_handling='memory' is set, no output txt files will be written.
        self.memory_result = {}

        # Start the run log.
        log = open(os.path.join(output_dir, "runs.tsv"), 'w')
        log.write("Simulation #\tInterval #\tOptions\tModel"
                  "\tParameters & initial values\n")
        self._log = log

        # Start counting the run() calls.
        self.simulation = 0

    def __delattr__(self, attr):
        """Delete a default option.
        """
        del self._options[attr]

    def __getattr__(self, attr):
        """If an unknown attribute is requested, look for it in the dictionary
        of default options.
        """
        return self._options[attr]

    def __setattr__(self, attr, value):
        """Add known attributes directly, but unknown attributes go to the
        dictionary of default options.
        """
        if attr in ('_output_dir', '_options', 'simulation',
                    '_log', '_current_model', 'memory_result', 'fmu'):
            object.__setattr__(self, attr, value) # Traditional method
        else:
            self._options[attr] = value

    def __enter__(self):
        """Enter the context of the simulator.
        """
        # Everything has been done in __init__, so just do this:
        return self

    def __exit__(self, *exc_details):
        """Exit the context of the simulator.
        """
        self._log.close()

    def _paths(self, model=None):
        """Given a FMU's path (*model*) and the internal state, return a tuple
        of:
        1. the FMU's directory
        2. the results directory

        Also, confirm that the FMU exists.

        Save the model.  If *model* is `None`, then use the last model.
        """

        # Locate the model.
        if model is None:
            model = self._current_model
        else:
            self._current_model = model
        assert os.path.isfile(model), (
            'The FMU (%s) cannot be found.' % os.path.abspath(model))

        # Return the directories.
        model_dir = os.path.dirname(model)
        output_dir = os.path.join(self._output_dir, str(self.simulation))
        return model_dir, output_dir

    def load(self, fmu_path, output_dir):
        """Load the FMU for continued simulation in :meth:`continue_run`.
        """

        import pyfmi

        if 'log_level' in self._options:
            self.fmu = pyfmi.load_fmu(fmu_path, log_level=self.log_level)
        else:
            self.fmu = pyfmi.load_fmu(fmu_path)

        # Initialize the fmu, only call setup_experiment for FMUs 2.0
        try:
            self.fmu.setup_experiment()
            version = 2
        except AttributeError:
            version = 1

        self.fmu.initialize()

        # Copy the log file to the result directory
        log = ''
        if version == 1:
            log = self.fmu.get_identifier()
        if version == 2:
            log = self.fmu.get_name()
        log += '_log.txt'
        source = os.path.join(os.getcwd(), log)
        destination = os.path.join(output_dir, 'log%i.txt' % self.interval)
        move(source, destination)

    def move_mat_file(self):
        """TODO
        """
        output_dir = self._paths()[1]
        source = os.path.join(os.getcwd(), 'Model_internal.mat')
        destination = os.path.join(output_dir, 'result.mat')
        copy(source, destination)

    def _run(self, params, options, model_dir, output_dir):
        """Write the given model parameters and initial values (*params*) and
        *output_dir*.  TODO Send the simulation options (*options*) to the FMU
        and save the results to the start and stop times are given in the same
        way as in :class:`dymosim`.

        Also write to the log file.
        """
        # Determine the file locations.
        dsres_path = os.path.join(output_dir, 'dsres%i.txt' % self.interval)

        # Write the simulation options.
        sim_options = self.fmu.simulate_options()

        for key, value in sim_options.iteritems():
            # Set the simulator options
            if key in self._options:
                sim_options[key] = self._options[key]
            # Overwrite simulator options with the options of the run method if
            # given
            if key in options:
                sim_options[key] = options[key]

        sim_options['initialize'] = False
        sim_options['result_file_name'] = dsres_path

        # Set start and stop times to be consistent across different simulators
        if 'StartTime' in options:
            start_time = options['StartTime']
        else:
            start_time = self.fmu.get_default_experiment_start_time()
        if 'StopTime' in options:
            stop_time = options['StopTime']
        else:
            stop_time = self.fmu.get_default_experiment_stop_time()

        # Set the simulation parameters
        self.fmu.set(params.keys(), params.values())

        # Run the model.
        self.memory_result[self.simulation][self.interval] = self.fmu.simulate(
            start_time=start_time,
            final_time=stop_time,
            options=sim_options
        )

        # Add an entry to the run log.
        self._log.write('\t'.join([str(self.simulation),
                                   str(self.interval),
                                   str(ParamDict(options))[1:-1],
                                   self.fmu.get_name(),
                                   str(ParamDict(params))[1:-1]])
                            + '\n')

    def run(self, model='model.fmu', params={}, **options):
        r"""Run and save the results of a single experiment.

        **Parameters:**

        - *model*: String representing the directory and base name of the fmu

             If *model* is `None`, then the previous model will be used.

        - *params*: Dictionary of names and values of parameters and variables
          with tunable initial values to be set within the model

             The keys or variable names in this dictionary must indicate the
             hierarchy within the model---either in Modelica_ dot ('.') notation
             or via nested dictionaries.  Due to the format of the
             initialization files, arrays must be broken into scalars by
             indicating the indices (Modelica_ 1-based indexing) in the key
             along with the variable name.  Also, enumerations and Booleans must
             be given as their unsigned integer equivalents (e.g., 0 for
             *False*).  Strings and prefixes are not supported.

             Any item with a value of `None` is skipped.

        - *\*\*options*: Adjustments to the simulation settings of an fmu and
          the start and stop times

             Any option with a value of `None` will be skipped.

             These are applied only for the current simulation.  They override
             the options given at initialization or set via attribute access.

        Please see the example in the top-level documentation of
        :class:`fmi`.
        """
        # Increment the number of runs and reset the number of intervals.
        self.simulation += 1
        self.interval = 1
        self.memory_result[self.simulation] = {}

        # Determine the file locations.
        model_dir, output_dir = self._paths(model)

        # Create the results folder.
        if not os.path.isdir(output_dir):
            os.makedirs(output_dir)

        # Load the fmu, write the parameters and options, run the model, and
        # save the results.
        self.load(model, output_dir)
        self._run(params, options, model_dir, output_dir)

    def continue_run(self, duration, params={}, **options):
        """Continue the last run (using the same model).

        **Parameters:**

        - *duration*: Number of additional seconds to simulate

        - *params*: Dictionary of names and values of parameters to be adjusted
          within the model

             By default, the parameters remain as they were in the last
             :meth:`run`.  See that method for details on *params*.

        - *\*\*options*: Adjustments to the simulation settings under
          "Experiment parameters", "Method tuning parameters", and "Output
          parameters" in the initialization file

             By default, the options remain as they were in the last
             :meth:`run`.  See that method for details.

             StartTime and StopTime are ignored because they are determined
             automatically from *duration* and the stop time of the last
             simulation.
        """
        # Increment the number of intervals.
        self.interval += 1

        # Determine the file locations.
        model_dir, output_dir = self._paths()

        # Run the simulation with the proper start and stop times.
        start_time = self.fmu.time
        options = {
            'StartTime': start_time,
            'StopTime': start_time + duration
        }
        self._run(params, options, model_dir, output_dir)

if __name__ == '__main__':
    # Test the contents of this file.

    import doctest
    doctest.testmod()
